node n1 {
    type router
    model router
    network-config {
	hostname n1
	!
	interface eth2
	 ip address 10.0.0.13/24
	!
	interface eth1
	 ip address 10.0.0.12/24
	!
	interface eth0
	 ip address 10.0.0.11/24
	!
    }
    canvas c1
    iconcoords {289.0 151.0}
    labelcoords {289.0 183.0}
    services {OvsService UserDefined}
    interface-peer {eth0 n2}
    interface-peer {eth1 n3}
    interface-peer {eth2 n4}
    custom-image /usr/local/share/core/icons/normal/pc.gif
    custom-config {
	custom-config-id service:OvsService
	custom-command OvsService
	config {
	files=('OvsService.sh', )
	}
    }
    custom-config {
	custom-config-id service:OvsService:OvsService.sh
	custom-command OvsService.sh
	config {
	#!/bin/sh
	# auto-generated by OvsService (OvsService.py)
	## First make sure that the ovs services are up and running
	/etc/init.d/openvswitch-switch start < /dev/null
	
	## create the switch itself, set the fail mode to secure, 
	## this stops it from routing traffic without defined flows.
	## remove the -- and everything after if you want it to act as a regular switch
	## ovs-vsctl add-br ovsbr0 -- set Bridge ovsbr0 fail-mode=secure
	ovs-vsctl add-br ovsbr0
	
	## Now add all our interfaces as ports to the switch
	## Create a veth pair to send the data to
	ip link add rtr0 type veth peer name sw0
	ip addr del 10.0.0.11 dev eth0
	ip addr add 10.0.0.11 dev rtr0
	## Add the CORE interface to the switch
	ovs-vsctl add-port ovsbr0 eth0 -- set Interface eth0 ofport_request=1
	## And then add its sibling veth interface
	ovs-vsctl add-port ovsbr0 sw0 -- set Interface sw0 ofport_request=2
	## start them up so we can send/receive data
	ovs-ofctl mod-port ovsbr0 eth0 up
	ovs-ofctl mod-port ovsbr0 sw0 up
	## Bring up the lower part of the veth pair
	ip link set dev rtr0 up
	## Create a veth pair to send the data to
	ip link add rtr1 type veth peer name sw1
	ip addr del 10.0.0.12 dev eth1
	ip addr add 10.0.0.12 dev rtr1
	## Add the CORE interface to the switch
	ovs-vsctl add-port ovsbr0 eth1 -- set Interface eth1 ofport_request=3
	## And then add its sibling veth interface
	ovs-vsctl add-port ovsbr0 sw1 -- set Interface sw1 ofport_request=4
	## start them up so we can send/receive data
	ovs-ofctl mod-port ovsbr0 eth1 up
	ovs-ofctl mod-port ovsbr0 sw1 up
	## Bring up the lower part of the veth pair
	ip link set dev rtr1 up
	## Create a veth pair to send the data to
	ip link add rtr2 type veth peer name sw2
	ip addr del 10.0.0.13 dev eth2
	ip addr add 10.0.0.13 dev rtr2
	## Add the CORE interface to the switch
	ovs-vsctl add-port ovsbr0 eth2 -- set Interface eth2 ofport_request=5
	## And then add its sibling veth interface
	ovs-vsctl add-port ovsbr0 sw2 -- set Interface sw2 ofport_request=6
	## start them up so we can send/receive data
	ovs-ofctl mod-port ovsbr0 eth2 up
	ovs-ofctl mod-port ovsbr0 sw2 up
	## Bring up the lower part of the veth pair
	ip link set dev rtr2 up
	
	## We assume there will be an SDN controller on the other end of this, 
	## but it will still function if there's not
	ovs-vsctl set-controller ovsbr0 tcp:127.0.0.1:6633
	
	## Now to create some default flows, 
	## if the above controller will be present then you probably want to delete them
	## Take the data from the CORE interface and put it on the veth and vice versa
	ovs-ofctl add-flow ovsbr0 priority=1000,in_port=1,action=output:2
	ovs-ofctl add-flow ovsbr0 priority=1000,in_port=2,action=output:1
	## Take the data from the CORE interface and put it on the veth and vice versa
	ovs-ofctl add-flow ovsbr0 priority=1000,in_port=3,action=output:4
	ovs-ofctl add-flow ovsbr0 priority=1000,in_port=4,action=output:3
	## Take the data from the CORE interface and put it on the veth and vice versa
	ovs-ofctl add-flow ovsbr0 priority=1000,in_port=5,action=output:6
	ovs-ofctl add-flow ovsbr0 priority=1000,in_port=6,action=output:5
	
	}
    }
    custom-config {
	custom-config-id service:UserDefined
	custom-command UserDefined
	config {
	files=('switch.py', 'switch1.py', 'run.sh', )
	cmdup=('chmod 777 run.sh', )
	}
    }
    custom-config {
	custom-config-id service:UserDefined:run.sh
	custom-command run.sh
	config {
	ryu-manager switch.py
	}
    }
    custom-config {
	custom-config-id service:UserDefined:switch1.py
	custom-command switch1.py
	config {
	from ryu.base import app_manager
	from ryu.controller import ofp_event
	from ryu.controller.handler import MAIN_DISPATCHER
	from ryu.controller.handler import set_ev_cls
	from ryu.ofproto import ofproto_v1_0
	class L2Switch(app_manager.RyuApp):
	    OFP_VERSIONS = [ofproto_v1_0.OFP_VERSION]
	    def __init__(self, *args, **kwargs):
	        super(L2Switch, self).__init__(*args, **kwargs)
	    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
	    def packet_in_handler(self, ev):
	        msg = ev.msg
	        dp = msg.datapath
	        ofp = dp.ofproto
	        ofp_parser = dp.ofproto_parser
	        actions = [ofp_parser.OFPActionOutput(ofp.OFPP_FLOOD)]
	        out = ofp_parser.OFPPacketOut(
	            datapath=dp, buffer_id=msg.buffer_id, in_port=msg.in_port,
	            actions=actions)
	        dp.send_msg(out)
	}
    }
    custom-config {
	custom-config-id service:UserDefined:switch.py
	custom-command switch.py
	config {
	import struct
	import logging
	
	from ryu.base import app_manager
	from ryu.controller import mac_to_port
	from ryu.controller import ofp_event
	from ryu.controller.handler import MAIN_DISPATCHER
	from ryu.controller.handler import set_ev_cls
	from ryu.ofproto import ofproto_v1_0
	from ryu.lib.mac import haddr_to_bin
	from ryu.lib.packet import packet
	from ryu.lib.packet import ethernet
	
	class L2Switch(app_manager.RyuApp):
	
	    OFP_VERSIONS = [ofproto_v1_0.OFP_VERSION]#define the version of OpenFlow
	
	    def __init__(self, *args, **kwargs):
	        super(L2Switch, self).__init__(*args, **kwargs)
	        self.mac_to_port = {}
	
	    def add_flow(self, datapath, in_port, dst, actions):
	        ofproto = datapath.ofproto
	
	        match = datapath.ofproto_parser.OFPMatch(
	            in_port = in_port, dl_dst = haddr_to_bin(dst))
	
	        mod = datapath.ofproto_parser.OFPFlowMod(
	            datapath = datapath, match = match, cookie = 0,
	            command = ofproto.OFPFC_ADD, idle_timeout = 10,hard_timeout = 30,
	            priority = ofproto.OFP_DEFAULT_PRIORITY,
	            flags =ofproto.OFPFF_SEND_FLOW_REM, actions = actions)
	
	        datapath.send_msg(mod)
	
	    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
	    def packet_in_handler(self, ev):
	        msg = ev.msg
	        datapath = msg.datapath
	        ofproto = datapath.ofproto
	
	        pkt = packet.Packet(msg.data)
	        eth = pkt.get_protocol(ethernet.ethernet)
	
	        dst = eth.dst
	        src = eth.src
	
	        dpid = datapath.id    #get the dpid
	        self.mac_to_port.setdefault(dpid, {})
	
	        self.logger.info("packet in %s %s %s %s", dpid, src, dst , msg.in_port)
	        #To learn a mac address to avoid FLOOD next time.
	
	        self.mac_to_port[dpid][src] = msg.in_port
	
	
	        out_port = ofproto.OFPP_FLOOD
	
	        #Look up the out_port 
	        if dst in self.mac_to_port[dpid]:
	            out_port = self.mac_to_port[dpid][dst]
	
	        ofp_parser = datapath.ofproto_parser
	
	        actions = [ofp_parser.OFPActionOutput(out_port)]
	
	        if out_port != ofproto.OFPP_FLOOD:
	            self.add_flow(datapath, msg.in_port, dst, actions)
	
	
	        #We always send the packet_out to handle the first packet.
	        packet_out = ofp_parser.OFPPacketOut(datapath = datapath, buffer_id = msg.buffer_id,
	            in_port = msg.in_port, actions = actions)
	        datapath.send_msg(packet_out)
	    #To show the message of ports' status.
	    @set_ev_cls(ofp_event.EventOFPPortStatus, MAIN_DISPATCHER)
	    def _port_status_handler(self, ev):
	        msg = ev.msg
	        reason = msg.reason
	        port_no = msg.desc.port_no
	
	        ofproto = msg.datapath.ofproto
	
	        if reason == ofproto.OFPPR_ADD:
	            self.logger.info("port added %s", port_no)
	        elif reason == ofproto.OFPPR_DELETE:
	            self.logger.info("port deleted %s", port_no)
	        elif reason == ofproto.OFPPR_MODIFY:
	            self.logger.info("port modified %s", port_no)
	        else:
	            self.logger.info("Illeagal port state %s %s", port_no, reason)
	}
    }
}

node n2 {
    type router
    model host
    network-config {
	hostname n2
	!
	interface eth0
	 ip address 10.0.0.1/24
	!
    }
    canvas c1
    iconcoords {142.0 338.0}
    labelcoords {142.0 370.0}
    interface-peer {eth0 n1}
    services {}
}

node n3 {
    type router
    model host
    network-config {
	hostname n3
	!
	interface eth0
	 ip address 10.0.0.2/24
	!
    }
    canvas c1
    iconcoords {300.0 347.0}
    labelcoords {300.0 379.0}
    interface-peer {eth0 n1}
    services {}
}

node n4 {
    type router
    model host
    network-config {
	hostname n4
	!
	interface eth0
	 ip address 10.0.0.3/24
	!
    }
    canvas c1
    iconcoords {519.0 319.0}
    labelcoords {519.0 351.0}
    interface-peer {eth0 n1}
    services {}
}

link l1 {
    nodes {n2 n1}
    bandwidth 0
}

link l2 {
    nodes {n3 n1}
    bandwidth 0
}

link l3 {
    nodes {n4 n1}
    bandwidth 0
}

canvas c1 {
    name {Canvas1}
}

option global {
    interface_names no
    ip_addresses yes
    ipv6_addresses no
    node_labels yes
    link_labels yes
    show_api no
    background_images no
    annotations no
    grid yes
    traffic_start 0
}

option session {
}

